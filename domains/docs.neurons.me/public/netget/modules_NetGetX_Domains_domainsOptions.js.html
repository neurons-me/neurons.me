

<!DOCTYPE html>
<html lang="en">

<head>
  ...
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>NetGet Documentation modules/NetGetX/Domains/domainsOptions.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">NetGet</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://docs.neurons.me/all.this/"
                        >
                            All.This
                        </a>
                    
                        <a
                            class="link user-link "
                            href="https://neurons.me"
                        >
                            Neurons.me
                        </a>
                    
                        <a
                            class="link user-link "
                            href="https://github.com/neurons-me/all.this"
                        >
                            Github
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-NetGetX.html">NetGetX</a></li><li><a href="module-PortManagement.html">PortManagement</a></li><li><a href="module-Srvrs_CLI.html">Srvrs_CLI</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-NetGetX.Config.html">Config</a></li><li><a href="module-NetGetX.Domains.html">Domains</a></li><li><a href="module-NetGetX.NginxConfiguration.html">NginxConfiguration</a></li><li><a href="module-NetGetX.OpenResty.html">OpenResty</a></li><li><a href="module-NetGetX.SSL.html">SSL</a></li><li><a href="module-NetGetX.Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="NetGet.html">NetGet</a></li></ul><h3>Global</h3><ul><li><a href="global.html#checkAndSetFilePermissions">checkAndSetFilePermissions</a></li><li><a href="global.html#checkPermissions">checkPermissions</a></li><li><a href="global.html#displayManualInstructions">displayManualInstructions</a></li><li><a href="global.html#domainsTable">domainsTable</a></li><li><a href="global.html#ensureDirectoryExists">ensureDirectoryExists</a></li><li><a href="global.html#execShellCommand">execShellCommand</a></li><li><a href="global.html#getDirectoryPaths">getDirectoryPaths</a></li><li><a href="global.html#getDomainsFromDB">getDomainsFromDB</a></li><li><a href="global.html#getLocalIP">getLocalIP</a></li><li><a href="global.html#getPublicIP">getPublicIP</a></li><li><a href="global.html#getState">getState</a></li><li><a href="global.html#handlePermission">handlePermission</a></li><li><a href="global.html#handlePermissionErrorForEnsureDir">handlePermissionErrorForEnsureDir</a></li><li><a href="global.html#initializeDirectories">initializeDirectories</a></li><li><a href="global.html#initializeState">initializeState</a></li><li><a href="global.html#pathExists">pathExists</a></li><li><a href="global.html#promptForDomainAndEmail">promptForDomainAndEmail</a></li><li><a href="global.html#retrieveSubdomainsTable">retrieveSubdomainsTable</a></li><li><a href="global.html#tryElevatedPrivileges">tryElevatedPrivileges</a></li><li><a href="global.html#updateState">updateState</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>modules/NetGetX/Domains/domainsOptions.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//netget/src/modules/NetGetX/Domains/domainsOptions.js
import inquirer from 'inquirer';
import chalk from 'chalk';
import NetGetX_CLI from '../NetGetX.cli.js';
import { loadOrCreateXConfig, saveXConfig } from '../config/xConfig.js';
import { scanAndLogCertificates } from './SSL/SSLCertificates.js';
import { registerDomain, deleteDomain, updateDomainTarget, updateDomainType } from '../../../sqlite/utils_sqlite3.js';
import domainsMenu from './domains.cli.js';
import sqlite3 from 'sqlite3';

/**
 * Retrieves and displays the subdomains table for a given domain.
 * @param {string} domain - The parent domain to list subdomains for.
 */
function retrieveSubdomainsTable(domain) {
    return new Promise((resolve, reject) => {
        const db = new sqlite3.Database('/opt/.get/domains.db', sqlite3.OPEN_READONLY);
        db.all(
            // Exclude rows where domain === subdomain (shouldn't happen, but just in case)
            'SELECT domain, target, type, subdomain FROM domains WHERE subdomain = ? AND domain != subdomain ORDER BY domain',
            [domain],
            (err, rows) => {
                db.close();
                if (err) {
                    console.log(chalk.red('Error reading subdomains:'), err.message);
                    return reject(err);
                }
            if (rows.length === 0) {
                // console.log(chalk.yellow('No subdomains configured for this domain.'));
                return resolve([]);
            } else {
                    console.log(chalk.blue('\nSubdomains for domain:'), chalk.green(domain));
                    const subDomainsTable = rows.map(row => ({
                        Subdomain: row.domain,
                        Target: row.target,
                        Type: row.type
                    }));
                    return resolve(subDomainsTable);
                }
            }
        );
    });
}

/**
 * Logs the domain information to the console.
 * @memberof module:NetGetX.Domains
 * @param {Object} domainConfig - The domain configuration object.
 * @param {string} domain - The domain name.
 */ 
async function logDomainInfo(domain) {
    // Mostrar información básica del dominio desde la base de datos
    // console.table([{
    //     Domain: domainConfig.domain,
    //     Target: domainConfig.target,
    //     Type: domainConfig.type,
    //     Owner: domainConfig.owner,
    //     Email: domainConfig.email
    // }]);
    try {
        const subDomainsTable = await retrieveSubdomainsTable(domain);
        if (subDomainsTable.length > 0) {
            console.table(subDomainsTable);
        } else {
            console.log(chalk.yellow('No subdomains configured for this domain.'));
        }
    } catch (err) {
        console.error(chalk.red('Error retrieving subdomains:'), err.message);
    }
}

/**
 * Displays the domains table by reading from the SQLite3 database.
 */
const domainsTable = () => {
    const db = new sqlite3.Database('/opt/.get/domains.db', sqlite3.OPEN_READONLY, (err) => {
        if (err) {
            console.log(chalk.red('Error opening database:'), err.message);
            return;
        }
    });

    db.all('SELECT domain, target, type FROM domains ORDER BY domain', [], (err, rows) => {
        if (err) {
            console.log(chalk.red('Error reading domains:'), err.message);
            db.close();
            return;
        }
        if (rows.length === 0) {
            console.log(chalk.yellow('No domains configured.'));
        } else {
            console.log(chalk.blue('\nDomains Information:'));
            console.table(rows.map(row => ({
                Domain: row.domain,
                Target: row.target,
                Type: row.type
            })));
        }
        db.close();
    });
};

const validateDomain = (domain) => {
    const domainRegex = /^(?!:\/\/)([a-zA-Z0-9-_]{1,63}\.)+[a-zA-Z]{2,6}$/;
    return domainRegex.test(domain) ? true : 'Enter a valid domain (e.g., example.com or sub.example.com)';
};


/**
 * Adds a new domain to the database.
 * @memberof module:NetGetX.Domains
 * @returns {Promise&lt;void>}
 */
const addNewDomain = async () => {
    while (true) {
        const description_message = 
            'Add a new domain to your NetGetX configuration. You can choose to serve static content or forward traffic to a specific port on your server.\n' +
            chalk.blue('Available Service Types:\n' +
            '- Serve Static Content: Host static files (like HTML, CSS, JS, images) from a folder on your server. Great for simple websites or landing pages.\n' +
            '- Forward Port: Forward all incoming traffic to a specific port on your server. Useful for connecting your domain to a backend service, app, or container running on a different port.\n\n') +
            chalk.white('Select the type of service for this domain:');
        const serviceTypeAnswer = await inquirer.prompt([
            {
            type: 'list',
            name: 'serviceType',
            message: description_message,
            validate: input => input ? true : 'Service type is required.',
            choices: [
                { name: 'Serve Static Content', value: 'static' },
                { name: 'Forward Port', value: 'server' },
                { name: 'Back', value: 'back' }
            ]
            }
        ]);

        if (serviceTypeAnswer.serviceType === 'back') {
            console.log(chalk.blue('Going back to the previous menu...'));
            return;
        }

        const type = serviceTypeAnswer.serviceType;

        let port = '';
        if (serviceTypeAnswer.serviceType === 'server') {
            const forwardPortAnswer = await inquirer.prompt([
            {
                type: 'input',
                name: 'server',
                message: 'Enter the forward port for this domain (type /b to go back):',
                validate: input => {
                if (input === '/b') return true;
                const portNum = Number(input);
                if (
                    !Number.isInteger(portNum) ||
                    portNum &lt; 1 ||
                    portNum > 65535
                ) {
                    return 'Enter a valid port number (1-65535)';
                }
                return true;
                }
            }
            ]);

            if (forwardPortAnswer.server === '/b') {
                console.log(chalk.blue('Going back to the previous menu...'));
                return;
            }

            port = forwardPortAnswer.server;
        } else if (serviceTypeAnswer.serviceType === 'static') {
            const staticPathAnswer = await inquirer.prompt([
                {
                    type: 'input',
                    name: 'staticPath',
                    message: 'Enter the path to the static file you want to serve (type /b to go back):',
                    validate: input => input ? true : 'Static file path is required.'
                }
            ]);

            if (staticPathAnswer.staticPath === '/b') {
                console.log(chalk.blue('Going back to the previous menu...'));
                return;
            }

            port = staticPathAnswer.staticPath;
        }

        const domainAnswer = await inquirer.prompt([
            {
                type: 'input',
                name: 'domain',
                message: 'Enter the new domain (e.g., example.com or sub.example.com) (type /b to go back):',
                validate: input => {
                    if (input === '/b') return true;
                    return validateDomain(input);
                }
            }
        ]);

        if (domainAnswer.domain === '/b') {
            console.log(chalk.blue('Going back to the previous menu...'));
            return;
        }

        const emailAnswer = await inquirer.prompt([
            {
            type: 'input',
            name: 'email',
            message: 'Enter the email associated with this domain (type /b to go back):',
            validate: input => {
                if (input === '/b') return true;
                // Simple email regex validation
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return emailRegex.test(input) ? true : 'Enter a valid email address.';
            }
            }
        ]);

        if (emailAnswer.email === '/b') {
            console.log(chalk.blue('Going back to the previous menu...'));
            return;
        }

        const ownerAnswer = await inquirer.prompt([
            {
                type: 'input',
                name: 'owner',
                message: 'Enter the owner of this domain (type /b to go back):',
                validate: input => input ? true : 'Owner is required.'
            }
        ]);

        if (ownerAnswer.owner === '/b') {
            console.log(chalk.blue('Going back to the previous menu...'));
            return;
        }

        const { domain, email, owner } = { ...domainAnswer, ...emailAnswer, ...ownerAnswer };

        // Verifica si el dominio ya existe en la base de datos
        const db = new sqlite3.Database('/opt/.get/domains.db', sqlite3.OPEN_READONLY);
        const exists = await new Promise((resolve) => {
            db.get('SELECT 1 FROM domains WHERE domain = ? AND subdomain IS NULL', [domain], (err, row) => {
                db.close();
                resolve(!!row);
            });
        });
        if (exists) {
            console.log(chalk.red(`Domain ${domain} already exists.`));
            return;
        }
        registerDomain(
            domain,
            domain,  // No subdomain for the main domain
            email,
            'letsencrypt',  // Default SSL mode
            '',
            '',  
            port,
            type,
            '',
            owner);

        console.log(chalk.green(`Domain ${domain} added successfully.`));
        return;  // Exit the loop after successful addition
    }
};

/**
 * Adds a subdomain to the specified domain.
 * @memberof module:NetGetX.Domains
 * @param {string} domain - The domain to add the subdomain to.
 * @returns {Promise&lt;void>}
 */
const addSubdomain = async (domain) => {
    try {
        const { subdomain } = await inquirer.prompt([
            {
                type: 'input',
                name: 'subdomain',
                message: 'Enter the subdomain name (type /b to go back):',
                validate: input => {
                    if (input === '/b') return true;
                    if (!input) return 'Subdomain name cannot be empty.';
                    return true;
                }
            }
        ]);

        if (subdomain === '/b') {
            console.log(chalk.blue('Going back to the previous menu...'));
            return;
        }

        const serviceTypeAnswer = await inquirer.prompt([
            {
            type: 'list',
            name: 'serviceType',
            message: 'Select the type of service for this domain:',
            choices: [
                { name: 'Serve Static Content', value: 'static' },
                { name: 'Forward Port', value: 'server' },
                { name: 'Back', value: 'back' }
            ]
            }
        ]);

        if (serviceTypeAnswer.serviceType === 'back') {
            console.log(chalk.blue('Going back to the previous menu...'));
            return;
        }

        let port = '';
        if (serviceTypeAnswer.serviceType === 'server') {
            const forwardPortAnswer = await inquirer.prompt([
                {
                    type: 'input',
                    name: 'server',
                    message: 'Enter the forward port for this domain (type /b to go back):',
                    validate: input => input ? true : 'Forward port is required.'
                }
            ]);

            if (forwardPortAnswer.server === '/b') {
                console.log(chalk.blue('Going back to the previous menu...'));
                return;
            }

            port = forwardPortAnswer.server;
        } else if (serviceTypeAnswer.serviceType === 'static') {
            const staticPathAnswer = await inquirer.prompt([
                {
                    type: 'input',
                    name: 'staticPath',
                    message: 'Enter the path to the static file you want to serve (type /b to go back):',
                    validate: input => input ? true : 'Static file path is required.'
                }
            ]);

            if (staticPathAnswer.staticPath === '/b') {
                console.log(chalk.blue('Going back to the previous menu...'));
                return;
            }

            port = staticPathAnswer.staticPath;
        }

        const ownerAnswer = await inquirer.prompt([
            {
            type: 'input',
            name: 'owner',
            message: 'Enter the owner of this subdomain (type /b to go back):',
            validate: input => input ? true : 'Owner is required.'
            }
        ]);

        if (ownerAnswer.owner === '/b') {
            console.log(chalk.blue('Going back to the previous menu...'));
            return;
        }

        // Retrieve email, SSLCertificateSqlitePath, and SSLCertificateKeySqlitePath from the parent domain in the database
        let parentDomainConfig;
        try {
            const db = new sqlite3.Database('/opt/.get/domains.db', sqlite3.OPEN_READONLY);
            parentDomainConfig = await new Promise((resolve, reject) => {
                db.get(
                    'SELECT email, sslCertificate, sslCertificateKey FROM domains WHERE domain = ?',
                    [domain],
                    (err, row) => {
                        db.close();
                        if (err) return reject(err);
                        resolve(row);
                    }
                );
            });
        } catch (err) {
            console.log(chalk.red('Error retrieving parent domain config:'), err.message);
            return;
        }

        if (!parentDomainConfig) {
            console.log(chalk.red(`Parent domain ${domain} not found in database.`));
            return;
        }

        try {
            await registerDomain(
                subdomain,
                domain,
                parentDomainConfig.email, 
                'letsencrypt', 
                parentDomainConfig.sslCertificate, 
                parentDomainConfig.sslCertificateKey, 
                port, 
                serviceTypeAnswer.serviceType,
                '',
                ownerAnswer.owner
            );
        } catch (err) {
            console.log(chalk.red('Error registering subdomain:'), err.message);
            return;
        }
    } catch (err) {
        console.log(chalk.red('An error occurred while adding the subdomain:'), err.message);
        return;
    }

    console.log(chalk.green(`Subdomain ${subdomain} added to domain ${domain}.`));
    return;
};

const editDomainDetails = async (domain) => {
    const editOptions = await inquirer.prompt([
        {
            type: 'list',
            name: 'editOption',
            message: 'Select an option to edit:',
            choices: [
                { name: 'Edit Type', value: 'editType' },
                { name: 'Edit Target', value: 'editTarget' },
                { name: 'Back to Domains Menu', value: 'back' }
            ]
        }
    ]);

    switch (editOptions.editOption) {
        case 'editType':
            const typeAnswer = await inquirer.prompt([
                {
                    type: 'list',
                    name: 'serviceType',
                    message: 'Select the new type of service for this domain:',
                    choices: [
                        { name: 'Serve Static Content', value: 'static' },
                        { name: 'Forward Port', value: 'server' },
                        { name: 'Back', value: 'back' }
                    ]
                }
            ]);
            if (typeAnswer.serviceType === 'back') {
                console.log(chalk.blue('Going back to the previous menu...'));
                return;
            }

            await updateDomainType(domain, typeAnswer.serviceType);
            break;

        case 'editTarget':
            const targetAnswer = await inquirer.prompt([
            {
                type: 'input',
                name: 'target',
                message: 'Enter the new target for this domain (type /b to go back):',
                validate: input => {
                if (input === '/b') return true;
                return input ? true : 'Target is required.';
                }
            }
            ]);
            if (targetAnswer.target === '/b') {
            console.log(chalk.blue('Going back to the previous menu...'));
            return;
            }
            await updateDomainTarget(domain, targetAnswer.target);
            break;

        case 'back':
            return;
    }
    return;
};

/**
 * Edits or deletes a domain from the database.
 * @memberof module:NetGetX.Domains
 * @param {string} domain - The domain to edit or delete.
 * @returns {Promise&lt;void>}
 */ 
const editOrDeleteDomain = async (domain) => {
    console.clear();
    try {
        // Leer la configuración del dominio desde la base de datos
        const db = new sqlite3.Database('/opt/.get/domains.db', sqlite3.OPEN_READONLY);
        const domainConfig = await new Promise((resolve, reject) => {
            db.get('SELECT * FROM domains WHERE domain = ?', [domain], (err, row) => {
                db.close();
                if (err) return reject(err);
                resolve(row);
            });
        });

        if (!domainConfig) {
            console.log(chalk.red(`Domain ${domain} configuration not found in database.`));
            return;
        }

        const options = [
            { name: 'Edit Domain', value: 'editDomain' },
            { name: 'Edit Subdomain', value: 'editSubdomain' },
            { name: 'Delete Domain', value: 'deleteDomain' },
            { name: 'Delete Subdomain', value: 'deleteSubdomain' },
            { name: 'Back', value: 'back' }
        ];

        const answer = await inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: 'Select an option:',
                choices: options
            }
        ]);

        switch (answer.action) {
            case 'editDomain':
                console.clear();
                await editDomainDetails(domain);
                console.log(chalk.green(`Domain ${domain} edited successfully.`));
                return;
            case 'editSubdomain':
                // Listar subdominios asociados a este dominio
                const dbSub = new sqlite3.Database('/opt/.get/domains.db', sqlite3.OPEN_READONLY);
                const subdomains = await new Promise((resolve) => {
                    dbSub.all('SELECT domain FROM domains WHERE subdomain = ? ORDER BY domain', [domain], (err, rows) => {
                        dbSub.close();
                        resolve(rows.map(r => r.domain));
                    });
                });
                if (subdomains.length === 0) {
                    console.log(chalk.red('No subdomains available to edit.'));
                } else {
                    const subDomainToEdit = await inquirer.prompt([
                        {
                            type: 'list',
                            name: 'subDomain',
                            message: 'Select a subdomain to edit:',
                            choices: [...subdomains, { name: 'Back', value: 'back' }]
                        }
                    ]);
                    if (subDomainToEdit.subDomain === 'back') {
                        console.log(chalk.blue('Going back to the previous menu...'));
                        return;
                    }
                    await editDomainDetails(subDomainToEdit.subDomain);
                }
                return;
            case 'deleteDomain':
                const confirmDelete = await inquirer.prompt([
                    {
                        type: 'confirm',
                        name: 'confirm',
                        message: `Are you sure you want to delete the domain ${domain}? (This will also delete all associated subdomains)`,
                        default: false
                    }
                ]);
                if (!confirmDelete.confirm) {
                    console.log(chalk.blue('Going back to the previous menu...'));
                    return;
                }
                // Elimina el dominio y sus subdominios asociados
                const dbDel = new sqlite3.Database('/opt/.get/domains.db');
                dbDel.run('DELETE FROM domains WHERE domain = ? OR subdomain = ?', [domain, domain], (err) => {
                    if (err) {
                        console.log(chalk.red('Error deleting domain:'), err.message);
                    } else {
                        console.log(chalk.green(`Domain ${domain} and its subdomains deleted successfully.`));
                    }
                    dbDel.close();
                });
                return;
            case 'deleteSubdomain':
                // Listar subdominios asociados a este dominio
                const dbSubDel = new sqlite3.Database('/opt/.get/domains.db', sqlite3.OPEN_READONLY);
                const subdomainsDel = await new Promise((resolve) => {
                    dbSubDel.all('SELECT domain FROM domains WHERE subdomain = ? AND subdomain!=domain ORDER BY domain', [domain], (err, rows) => {
                        dbSubDel.close();
                        resolve(rows.map(r => r.domain));
                    });
                });
                if (subdomainsDel.length === 0) {
                    console.log(chalk.red('No subdomains available to delete.'));
                } else {
                    const subDomainToDelete = await inquirer.prompt([
                        {
                            type: 'list',
                            name: 'subDomain',
                            message: 'Select a subdomain to delete:',
                            choices: [...subdomainsDel, { name: 'Back', value: 'back' }]
                        }
                    ]);
                    if (subDomainToDelete.subDomain === 'back') {
                        console.log(chalk.blue('Going back to the previous menu...'));
                        return;
                    }
                    const confirmDeleteSub = await inquirer.prompt([
                        {
                            type: 'confirm',
                            name: 'confirm',
                            message: `Are you sure you want to delete the subdomain ${subDomainToDelete.subDomain}?`,
                            default: false
                        }
                    ]);
                    if (!confirmDeleteSub.confirm) {
                        console.log(chalk.blue('Subdomain deletion was cancelled.'));
                        return;
                    }
                    const dbDelSub = new sqlite3.Database('/opt/.get/domains.db');
                    dbDelSub.run('DELETE FROM domains WHERE domain = ? AND subdomain = ?', [subDomainToDelete.subDomain, domain], (err) => {
                        if (err) {
                            console.log(chalk.red('Error deleting subdomain:'), err.message);
                        } else {
                            console.log(chalk.green(`Subdomain ${subDomainToDelete.subDomain} deleted successfully.`));
                        }
                        dbDelSub.close();
                    });
                }
                return;
            case 'back':
                return;
        }

        // After an action, redisplay the menu
        await editOrDeleteDomain(domain);
    } catch (error) {
        console.error(chalk.red('An error occurred in the Edit/Delete Domain Menu:', error.message));
    }
};

/**
 * Displays the advance settings for the domain.
 * @memberof module:NetGetX.Domains
 * @returns {Promise&lt;void>}
 */
const advanceSettings = async () => {
    try{
        const answers = await inquirer.prompt({
            type: 'list',
            name: 'action',
            message: 'Select an option:',
            choices: [
            { name: 'Scan All SSL Certificates Issued', value: 'scan' },
            { name: 'View Certbot Logs', value: 'logs' },
            { name: 'Back', value: 'back' }
            ]
        });

        switch (answers.action) {
            case 'scan':
                await scanAndLogCertificates();
            case 'logs':
                console.log(chalk.yellow('Certbot logs soon to be implemented.'));
            case 'back':
                console.log(chalk.blue('Going back to the previous menu...'));
                return;
        }
    await advanceSettings();
    } 
    catch (error) {
        console.error(chalk.red('An error occurred in the Advance Domain Menu:', error.message));
    }    
};

const linkDevelopmentAppProject = async (domain) => {
    const { projectPath } = await inquirer.prompt([
        {
            type: 'input',
            name: 'projectPath',
            message: 'Enter the path where the project is being developed:',
        }
    ]);

    const xConfig = await loadOrCreateXConfig();
    xConfig.domains[domain].projectPath = projectPath;
    await saveXConfig(xConfig);
    await updateDomain(
        domain,
        xConfig.domains[domain].email,
        'letsencrypt',
        xConfig.domains[domain].SSLCertificateSqlitePath, 
        xConfig.domains[domain].SSLCertificateKeySqlitePath, 
        xConfig.domains[domain].target,
        xConfig.domains[domain].type,
        projectPath
    );

    console.log(chalk.green(`Linked development app project at ${projectPath} with domain ${domain}.`));
};

export {
    validateDomain,
    addNewDomain,
    addSubdomain,
    editOrDeleteDomain,
    logDomainInfo,
    linkDevelopmentAppProject,
    domainsTable,
    advanceSettings
};
</code></pre>
        </article>
    </section>






            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>
<style>
.center-div {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 89px;
}

img {
  max-width: 100%;
  max-height: 100%;
}
</style>

<a href="http://neurons.me" target="_blank">By neurons.me</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>


</body>
</html>
